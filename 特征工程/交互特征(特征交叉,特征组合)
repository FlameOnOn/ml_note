两个特征的乘积可以组成一对简单的交互特征，这种相乘关系可以用逻辑操作符 AND 来类比. 两两组和.
# 创建交互特征对，跳过固定偏移项
import sklearn.preprocessing as preproc
>>> X2 = preproc.PolynomialFeatures(include_bias=False).fit_transform(X)
r_score = model.score(X_test, y_test)
交互特征的构造非常简单，使用起来却代价不菲。如果线性模型中包含有交互特征对，那
它的训练时间和评分时间就会从 O(n) 增加到 O(n方)，其中 n 是单一特征的数量。(因为要是两两组合的画,特征数量增加了C n 2这么多个)

对于这个r_score还要好好看看到底怎么算的.  

有若干种方法可以绕过高阶交互特征所带来的计算成本。
我们可以在构造出所有交互特征之后再执行特征选择，或者，也可以更加精心地设计出少量复杂特征。
这两种策略各有千秋。特征选择使用计算手段为一个具体问题选择出最佳特征。（这种
技术并不局限于交互特征。）但是，一些特征选择技术仍然需要使用大量特征去训练多个
模型。
精心设计的复杂特征需要昂贵的成本，所以数量不能太多，它们可以减少模型的训练时
间，但特征本身会消耗很多计算能力，这增加了模型评分阶段的计算成本。
